---
title: "Notes on 'Analyzing US Census Data'"
author: "Rick Dean"
format: 
  html:
    toc: false
    toc-depth: 4
    toc-location: "right"
    number-sections: true
    number-offset: 1
    self-contained: true
    smooth-scroll: true
    code-fold: false
    code-block-bg: "#f1f3f5"
    code-block-border-left: "#31BAE9"
    code-overflow: wrap
    tbl-cap-location: "bottom"
    fig-width: 7
    fig-asp: 0.6
    fig-align: "center"
    fig-cap-location: "bottom"
    css: ../style.css
    link-external-newwindow: true
    abstract-title: "Abstract"
    abstract: "The following are notes and R script based on Chapter 2 of the book [Analyzing US Census Data: Methods, Maps, and Models in R](https://walker-data.com/census-r/index.html) by Kyle Walker with its presentation of examples and exercises.  The R packages [RcensusPkg](https://github.com/deandevl/RcensusPkg) and [data.table](https://cran.r-project.org/web/packages/data.table/index.html) are used in accessing and manipulating the data respectively. The tables are created by using the R package [RplotterPkg::create_table()](https://github.com/deandevl/RplotterPkg)."
---

# An Introduction to tidycensus (RcensusPkg)

::: task
Load the Required R Packages:
:::

```{r}
#| warning: false
#| message: false

library(usmap)
library(data.table)
library(stringr)
library(gt)
library(purrr)
library(magrittr)
library(RcensusPkg)
```

## Getting started with tidycensus (RcensusPkg)

Set up the census key in order to access the Census Bureau's api. All API requests to the Census Bureau require a "key" in the http url address. Sign-up for a key is free and can be obtained [here](https://api.census.gov/data/key_signup.html). `RcensusPkg` will automatically attach this "key" to each request. All the package functions will check for a global setting of the key via `Sys.getenv("CENSUS_KEY")`. Run `usethis::edit_r_environ()` and edit your .Renviron file with the line: `CENSUS_KEY=your key` to create the global association.

### The Decennial Census

::: task
From the Decennial Census data set ("dec/sf1") get the total population for each state for 2010.
:::

We are interested in data set "dec/sf1" and variable "P001001" (which is TOTAL POPULATION) in our request to the Census Bureau.

Call `RcensusPkg::get_vintage_data()`:

```{r}
sf1_pop_2010_dt <- RcensusPkg::get_vintage_data(
  dataset = "dec/sf1",
  vintage = 2010,
  vars = "P001001",
  region = "state"
) %>% 
data.table::setnames(old = "P001001", new = "value")  %>% 
.[, `:=`(variable = "P001001", state = NULL)] %>% 
.[, .(GEOID, NAME, variable, value)]
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.1: Total population by state, dec/sf1, 2010

total_pop_gt <- RplotterPkg::create_table(
  x = sf1_pop_2010_dt[1:6,],
  container_width_px = 400
)
total_pop_gt
```

#### Summary files in the Decennial Census

::: task
Retrieve information on the American Indian & Alaska Native population by state from the 2020 summary #decennial Census.
:::

Use `RcensusPkg::get_vintage_data()` with arguments `vars` set to "P1_005N" and `dataset` set to "dec/pl":

```{r}
aian_2020_dt <- RcensusPkg::get_vintage_data(
  dataset = "dec/pl",
  vintage = 2020,
  vars = "P1_005N",
  region = "state"
) %>% 
data.table::setnames(old = "P1_005N", new = "value")  %>% 
.[, `:=`(variable = "P1_005N", state = NULL)] %>% 
.[, .(GEOID, NAME, variable, value)]  
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.2: Population of Indian & Alaska Native by state, dec/pl, 2020

aian_2020_gt <- RplotterPkg::create_table(
  x = aian_2020_dt[1:6, ],
  container_width_px = 400
)
aian_2020_gt
```

### American Community Survey (ACS)

From the ACS we are interested in "B05006_150E" and "B05006_150M" which the Census Bureau describes as

> Concept -- PLACE OF BIRTH FOR THE FOREIGN-BORN POPULATION IN THE UNITED STATES
>
> Label -- Estimate!!Total:!!Americas:!!Latin America:!!Central America:!!Mexico
>
> "B05006_150E" and "B05006_150M" fetches data on the number of residents born in Mexico by state.

::: task
From the 5-year ACS survey data set ("acs/acs5") retrieve variables "B05006_150E" and "B05006_150M" for 2020 for each state.
:::

::: note
Note that there is also a 1-year survey ("acs/acs1").
:::

Call `RcensusPkg::get_vintage_data()`:

```{r}
born_in_mexico_5yr_dt <- RcensusPkg::get_vintage_data(
  dataset = "acs/acs5",
  vintage = 2020,
  vars = c("B05006_150E", "B05006_150M"),
  region = "state"
) %>% 
data.table::setnames(old = c("B05006_150E", "B05006_150M"), new = c("estimate", "moe")) %>%   
.[, variable := "B05006_150"]  %>% 
data.table::setorder(NAME) %>% 
.[, c("GEOID", "NAME", "variable", "estimate", "moe")]
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.3: Mexican-born population by state, acs/acs5, 2020

born_in_mexico_5yr_gt <- RplotterPkg::create_table(
  x = born_in_mexico_5yr_dt[1:6,],
  container_width_px = 400
)
born_in_mexico_5yr_gt
```

::: task
Get the 1-year ACS survey of "B05006_150E" and "B05006_150M" for 2020 for each state.
:::

Call `RcensusPkg::get_vintage_data()`:

```{r}
born_in_mexico_1yr_dt <- RcensusPkg::get_vintage_data(
  dataset = "acs/acs1",
  vintage = 2019,
  vars = c("B05006_150E", "B05006_150M"),
  region = "state"
) %>% 
data.table::setnames(old = c("B05006_150E", "B05006_150M"), new = c("estimate", "moe")) %>%
.[, variable := "B05006_150"]  %>%
data.table::setorder(NAME) %>%
.[, c("GEOID", "NAME", "variable", "estimate", "moe")]
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.4: Mexican-born population by state, acs/acs1, 2019

born_in_mexico_1yr_gt <- RplotterPkg::create_table(
  x = born_in_mexico_1yr_dt[1:6,],
  container_width_px = 400
)
born_in_mexico_1yr_gt
```

We can get many related variables at once using a `group` (sometimes referred to as a "table"), defined by the Census Bureau.

::: task
Using the list of variables associated with the group/table named "B01001" (which covers sex broken down by age, from the 2015-2020 5-year ACS) get the estimated values for each by state.
:::

Use `RcensusPkg::get_vintage_data()` and set the `group` parameter to "B01001":

```{r}
B01001_dt <- RcensusPkg::get_vintage_data(
  dataset = "acs/acs5",
  vintage = 2020,
  group = "B01001",
  region = "state",
  wide_to_long = T
) %>% 
  data.table::setorderv(cols = "NAME")
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.5: Group B01001 by state, acs/acs5, 2020

B01001_gt <- RplotterPkg::create_table(
  x = B01001_dt[1:6],
  container_width_px = 400
) 
B01001_gt
```

## Geography and variables in tidycensus(RcensusPkg)

::: task
Get the available geography for "acs/acs5" for 2016-2020 5-year ACS.
:::

Call `RcensusPkg::get_geography()`:

```{r}
acs5_geo_dt <- RcensusPkg::get_geography(
  dataset = "acs/acs5",
  vintage = 2020
)
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.6: Available geographies, acs/acs5, 2020

acs5_geo_gt <- RplotterPkg::create_table(
  x = acs5_geo_dt[1:6],
  footnote_col_head_lst = list(
    footnote = "Showing the first 6 of 87 geographies",
    col = 1
  ),
  container_width_px = 400
)
acs5_geo_gt
```

::: task
Show the row information for the core-based statistical areas("cbsa") and zip code tabulation areas("zcta").
:::

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.6-1: Core-based statistical areas and zip code tabulation areas, acs/acs5, 2020

zip_gt <- RplotterPkg::create_table(
  x = acs5_geo_dt[geoLevelDisplay=="310" | geoLevelDisplay == "860",],
  container_width_px = 400
)
zip_gt
```

::: task
Using the "cbsa" geography level find the estimates for variable "B01003_001".
:::

What is "B01003_001"?
```{r}
B01003_001_dt <- RcensusPkg::get_variable_names(
  dataset = "acs/acs5",
  vintage = 2020,
  vars = "B01003_001E"
)
```
```{r}
#| code-fold: true
#| tbl-cap: |
#|   What is "B01003_001", acs/acs5, 2020

B01003_001_gt <- RplotterPkg::create_table(
  x = B01003_001_dt,
  container_width_px = 400
)
B01003_001_gt
```


Call `RcensusPkg::get_vintage_data()`:

```{r}
acs5_cbsa_dt <- RcensusPkg::get_vintage_data(
  dataset = "acs/acs5",
  vintage = 2020,
  vars = c("B01003_001E", "B01003_001M"),
  region = "metropolitan statistical area/micropolitan statistical area",
) %>% 
data.table::setnames(., old = c("B01003_001E", "B01003_001M"), new = c("estimate", "moe")) %>% 
.[, `:=`(`metropolitan statistical area/micropolitan statistical area` = NULL, variable = "B01003_001", moe = ifelse(moe == "-555555555",NA,moe))] %>% 
.[, c("GEOID", "NAME", "variable", "estimate", "moe")]  
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.6-2: B01003_001 Estimates on 'cbsa' Geography Level, acs/acs5, 2020

acs5_cbsa_gt <- RplotterPkg::create_table(
  x = acs5_cbsa_dt[1:6,],
  container_width_px = 400
)
acs5_cbsa_gt
```

### Geographic subsets

Getting Census Bureau estimates at the state and county level.

::: task
For all counties in the state of Wisconsin find the estimated household income from "acs/acs5" for 2020.
:::

Get the fips number for Wisconsin:

```{r}
wis_fips <- usmap::fips("WI")
```

Get the household income ("B19013_001E","B19013_001M") for all the counties in Wisconsin:

```{r}
wi_income_dt <- RcensusPkg::get_vintage_data(
  dataset = "acs/acs5",
  vintage = 2020,
  vars = c("B19013_001E", "B19013_001M"),
  region = "county:*",
  regionin = paste0("state:", wis_fips)
) %>% 
data.table::setnames(., old = c("B19013_001E", "B19013_001M"), new = c("estimate", "moe")) %>% 
.[, `:=`(state = NULL, county = NULL, variable = "B19013_001")] %>% 
.[order(NAME)] %>% 
.[, c("GEOID", "NAME", "variable", "estimate", "moe")]    
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.7: Wisconsin Counties' Household Income, acs/acs5, 2020

wi_income_gt <- RplotterPkg::create_table(
  x = wi_income_dt[1:6, ],
  container_width_px = 400
)
wi_income_gt
```

::: note
Note that we received 72 rows/observations for the 72 counties in Wisconsin in reporting household income using the ACS 5-year dataset:
:::

```{r}
#| code-fold: true
wi_income_acs5_rows <- nrow(wi_income_dt)
```

Rows from Wisconsin counties' ACS 5-year household income: `r wi_income_acs5_rows`.

::: task
Find Census Bureau household income estimates at the tract level for Dane County in Wisconsin.
:::

Get the fips numbers for Dane County and Wisconsin:

```{r}
wi_dane_fips <- usmap::fips(state = "WI", county = "Dane")
wi_fips <- substr(wi_dane_fips,1,2)
dane_fips <- substr(wi_dane_fips,3,5)
```

Request the data from the "acs/acs5" dataset:

```{r}
dane_income_dt <- RcensusPkg::get_vintage_data(
  dataset = "acs/acs5",
  vintage = 2020,
  vars = c("B19013_001E", "B19013_001M"),
  region = "tract:*",
  regionin = paste0("state:", wi_fips, "+county:", dane_fips)
) %>% 
data.table::setnames(., old = c("B19013_001E", "B19013_001M"), new = c("estimate", "moe")) %>% 
.[, `:=`(state = NULL, county = NULL, tract = NULL, variable = "B19013_001")] %>% 
.[, c("GEOID", "NAME", "variable", "estimate", "moe")]
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.8: Dane County, Wisconsin Household Income, acs/acs5, 2020

dane_income_gt <- RplotterPkg::create_table(
  x = dane_income_dt[1:6,],
  container_width_px = 400
)
dane_income_gt
```

We noted above that for county household income in Wisconsin we obtained 72 rows from the 5-year ACS.

::: task
How many rows would we obtain requesting the same data from the American Community Survey: 1-Year Estimates("acs/acs1")?
:::

Repeat the above request for the 1-year ACS dataset:

```{r}
wi_income_1yr_dt <- RcensusPkg::get_vintage_data(
  dataset = "acs/acs1",
  vintage = 2019,
  vars = c("B19013_001E", "B19013_001M"),
  region = "county:*",
  regionin = paste0("state:", wi_fips),
)
```

::: note
Note that there are only 23 rows in the data table, representing the 23 counties that meet the "total population of 65,000 or greater" criteria for the ACS 1-year survey.
:::

```{r}
#| code-fold: true
wi_income_acs1_rows <- nrow(wi_income_1yr_dt)
```

Rows from Wisconsin counties' ACS 1-year household income: `r wi_income_acs1_rows`.

## Searching for variables in tidycensus(RcensusPkg)

The `RcensusPkg::get_variable_names()` function provides a way to determine the availability and variable acronyms from the various datasets. It has a requirement for the dataset name along with optional parameters for `vintage`, and `group`.

The function also has the `filter_name_str/filter_label_str` -- character strings by which to filter the resultant data.table using the "name" and/or "label" columns. If the `group` parameter is defined, the function has a `filter_group` logical parameter which if TRUE will return only estimate and margin of error related variables.

::: note
Be aware that `RcensusPkg::get_variable_names()` can be time consuming. The following request is an example of a time consumer that returns a data frame with over 22000 rows of variable names if unfiltered.
:::

::: task
Find the variables available under the "acs/acs5" dataset for vintage 2016.
:::

Call `RcensusPkg::get_variable_names()`:

```{r}
acs5_vars_dt <- RcensusPkg::get_variable_names(
  dataset = "acs/acs5",
  vintage = 2016
) %>% 
na.omit(., cols = "concept")  
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.9: Census Bureau variables, acs/acs5, 2016 

acs5_vars_gt <- RplotterPkg::create_table(
  x = acs5_vars_dt[1:6, ],
  footnote_col_head_lst = list(
    footnote = "22819 total variables",
    col = 2
  ),
  container_width_px = 500
)
acs5_vars_gt
```

## Data structure in tidycensus(RcensusPkg)

In calling `RcensusPkg::get_vintage_data()` with "group" specified the data.table outputs are in a shape called the "wide" form with each column representing a specific variable. To reshape the data.table to a "long" form, we can set the functions "wide_to_long" to TRUE.

::: task
Show the resulting "long" form when we define the `group` parameter as "B19001" from the "acs/acs1" dataset by state.
:::

Call `RcensusPkg::get_vintage_data()` for group "B19001":

```{r}
B19001_1yr_dt <- RcensusPkg::get_vintage_data(
  dataset = "acs/acs1",
  vintage = 2016,
  group = "B19001",
  region = "state",
  wide_to_long = T
) %>% 
.[order(NAME)]
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.10: Long table (884 x 5) B19001 Variables, acs/acs1, 2016

B19001_1yr_gt <- RplotterPkg::create_table(
  x = B19001_1yr_dt[1:6,],
  container_width_px = 400
)
B19001_1yr_gt
```

::: note
Note that we are showing a data.table with 884 rows and 5 columns. This is the "long" form.
:::

::: task
Using `RcensusPkg::long_to_wide()` create a "wide" form of `B19001_1yr_dt`.
:::

We can reshape `B19001_1yr_dt` where the unique values under the "variable" column become the columns.

Call `RcensusPkg::long_to_wide()`:

```{r}
B19001_1yr_wide_dt <- RcensusPkg::long_to_wide(
  dt = B19001_1yr_dt,
  parameter_col = "variable",
  value_col = c("estimate", "moe")
)
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.11: Wide table (57 x 36) B19001 Variables, acs/acs1, 2016

B19001_1yr_wide_gt <- RplotterPkg::create_table(
  x = B19001_1yr_wide_dt[1:6, 1:6],
  container_width_px = 600
)
B19001_1yr_wide_gt
```

::: note
Note that we are showing a data.table with 52 rows and 36 columns of "estimate" and "moe". This is the "wide" form.
:::

### Understanding GEOIDs

::: task
Find the number of households in Cimarron County, Oklahoma using the GEOID block level from the 2020 Census.
:::

Get the fips numbers for Cimarron County and Oklahoma:

```{r}
ok_cim_fips <- usmap::fips(state = "OK", county = "Cimarron")
ok_fips <- substr(ok_cim_fips,1,2)
cim_fips <- substr(ok_cim_fips,3,5)
```

Call `RcensusPkg::get_vintage_data`:

```{r}
cimarron_blocks_dt <- RcensusPkg::get_vintage_data(
  dataset = "dec/pl",
  vintage = 2020,
  vars = "H1_001N",
  region = "block:*",
  regionin = paste0("state:", ok_fips, "+county:", cim_fips) )%>% 
  .[order(GEOID)] %>% 
.[, `:=`(variable = "H1_001N")] %>% 
data.table::setnames(., old = "H1_001N", new = "value") %>% 
.[, .(GEOID, NAME, variable, value)]  
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.12: Households by block in Cimarron County, OK 

cimarron_blocks_gt <- RplotterPkg::create_table(
  x = cimarron_blocks_dt[1:6,],
  container_width_px = 600
)
cimarron_blocks_gt
```

### Renaming variable IDs

Using the data.table package we can reassign Census IDs to new names.

::: task
Taking the counties in Georgia from the 2015-2019 five-year ACS show the median age and income.
:::

Call `RcensusPkg::get_vintage_data()` and rename the variables:

```{r}
ga_fips <- usmap::fips("GA")
ga_dt <- RcensusPkg::get_vintage_data(
  dataset = "acs/acs5",
  vintage = 2020,
  vars = c("B19013_001E", "B01002_001E", "B19013_001M", "B01002_001M"),
  region = "county:*",
  regionin = paste0("state:", ga_fips)) %>% 
  .[order(NAME)] %>% 
  data.table::setnames(.,old=c("B01002_001E","B01002_001M","B19013_001E", "B19013_001M"), new=c("medageE", "medageM", "medincE", "medincM")) %>% 
  .[, .(GEOID, NAME, medageE, medageM, medincE, medincM)]
```

The result is a data.table in its default "wide" format with the renamed variables.

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.14: Georgia Counties dataset (wide form), acs/acs5, 2020

ga_gt <- RplotterPkg::create_table(
  x = ga_dt[1:6,],
  container_width_px = 500
)
ga_gt
```

Reshape the data.table into a "long" format:

```{r}
ga_long_dt <- RcensusPkg::wide_to_long(
  dt = ga_dt
)
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.13: Multi-variable dataset for Georgia counties (long form), acs/acs5, 2020

ga_long_gt <- RplotterPkg::create_table(
  x = ga_long_dt[1:6,],
  container_width_px = 400
)
ga_long_gt
```

## Other Census Bureau datasets in tidycensus(RcensusPkg)

### Using tidycensus::get_estimates() (Data from the Population Estimates Program (PEP))

PEP as described by the Census Bureau:

> PEP annually utilizes current data on births, deaths, and migration to calculate population change since the most recent decennial census and produces a time series of estimates of population, demographic components of change, and housing units.

::: task
For the county of Queens, NY request all variables that are components of change population estimates for 2019. We will be using the "pep/components" dataset.
:::

Call `RcensusPkg::get_vintage_data()`:

```{r}
ny_queens_fips <- usmap::fips(state = "NY", county = "Queens")

queens_components_dt <- RcensusPkg::get_vintage_data(
  dataset = "pep/components",
  vintage = 2019,
  vars = c("BIRTHS","DEATHS","DOMESTICMIG","INTERNATIONALMIG","NATURALINC","NETMIG","RBIRTH","RDEATH","RDOMESTICMIG","RINTERNATIONALMIG"),
  region = paste0("county:", substr(ny_queens_fips,3,5)),
  regionin = paste0("state:", substr(ny_queens_fips,1,2))
) %>%
.[, `:=`(state = NULL, county = NULL)]
```

Reshape `queens_components_dt` in the "long" format:

```{r}
queens_components_long_dt <- RcensusPkg::wide_to_long(
  dt = queens_components_dt
)
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.15: Components of change estimates for Queens County, NY, pep/components, 2019

queens_components_long_gt <- RplotterPkg::create_table(
  x = queens_components_long_dt,
  container_width_px = 400
)
queens_components_long_gt
```

The above table reflects data from the "pep/components" dataset in the Population Estimates Program (pep). What other datasets are available in the "pep".

::: task
Get a listing of all the Population Estimates Program (pep) related datasets for the year 2019.
:::

Call `RcensusPkg::get_dataset_names()` for a brief listing using "pep" as a filter to the "title" column:

```{r}
pep_datasets_dt <- RcensusPkg::get_dataset_names(
  filter_title_str = "population estimates",
  vintage = 2019) 
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.15-1 Population Estimates Program (pep) related datasets, 2019

pep_datasets_gt <- RplotterPkg::create_table(
  x = pep_datasets_dt,
  container_width_px = 500
)
pep_datasets_gt
```

::: task
From the PEP "pep/charagegroups" dataset get the characteristics for Louisiana, 2019. We are interested in variables "SEX", "HISP", and "POP".
:::

Call `RcensusPkg::get_vintage_data()`:

```{r}
la_fips <- usmap::fips("LA")
louisiana_sex_hisp_dt <- RcensusPkg::get_vintage_data(
  dataset = "pep/charagegroups",
  vintage = 2019,
  vars = c("SEX","HISP","POP"),
  region = paste0("state:", la_fips)) %>%
data.table::setnames(., old = "POP", new = "value") %>%
.[, .(GEOID, NAME, value, SEX, HISP)]
```

Using `data.table` techniques do some minor wrangling by converting the values for variables "SEX" and "HISP" from "0"'s and "1"'s to more descriptive values:

```{r}
louisiana_sex_hisp_dt[, SEX := fcase(
  SEX == "0", "Both sexes",
  SEX == "1", "Male",
  SEX == "2", "Female"
)]

louisiana_sex_hisp_dt[, HISP := fcase(
  HISP == "0", "Both Hispanic Origins",
  HISP == "1", "Non-Hispanic",
  HISP == "2", "Hispanic"
)]
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.16: Population characteristics for Louisiana, pep/charagegroups, 2019

louisiana_sex_hisp_gt <- RplotterPkg::create_table(
  x = louisiana_sex_hisp_dt,
  container_width_px = 400
)
louisiana_sex_hisp_gt
```

::: task
Variables available from the dataset "pep/charagegroups" have characteristic breakdowns for Age Group, Sex, Race, and Hispanic Origins. Get a listing of all the variables in this dataset.
:::

Call `RcensusPkg::get_variable_names()`:

```{r}
pep_char_vars_dt <- RcensusPkg::get_variable_names(
  dataset = "pep/charagegroups",
  vintage = 2019
)
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.16-1: All variables, pep/charagegroups,2019

pep_char_vars_gt <- RplotterPkg::create_table(
  x = pep_char_vars_dt,
  container_width_px = 500
)
pep_char_vars_gt
```

### Using get_flows() (ACS Migration Flows API)

The Census Bureau offers data on both in- and out-migration for states, counties, and metropolitan areas.

::: task
Find the migration flows data for Honolulu County, Hawaii from the "acs/flows" dataset for 2019.
:::

From the "acs/flows" dataset of the American Community Survey we will be using the variables "FULL1_NAME", "FULL2_NAME", "MOVEDIN", "MOVEDIN_M","MOVEDOUT", "MOVEDOUT_M","MOVEDNET","MOVEDNET_M".

Call `RcensusPkg::get_vintage_data()`:

```{r}
honolulu_fips <- usmap::fips(state = "HI", county = "Honolulu")
honolulu_migration_dt <- RcensusPkg::get_vintage_data(
  dataset = "acs/flows",
  vintage = 2019,
  NAME_GEOID = FALSE,
  vars = c("GEOID1", "GEOID2", "FULL1_NAME", "FULL2_NAME", "MOVEDIN", "MOVEDIN_M","MOVEDOUT", "MOVEDOUT_M","MOVEDNET","MOVEDNET_M"),
  region = paste0("county:", substr(honolulu_fips,3,5)),
  regionin = paste0("state:", substr(honolulu_fips,1,2))
)
```

Reshape `honolulu_migration_dt` to the "long" format:

```{r}
honolulu_migration_est_dt <- RcensusPkg::wide_to_long(
  dt = honolulu_migration_dt,
  id_v = c("GEOID1", "GEOID2", "FULL1_NAME", "FULL2_NAME"),
  measure_v = c("MOVEDIN", "MOVEDOUT", "MOVEDNET")
)

honolulu_migration_moe_dt <- RcensusPkg::wide_to_long(
  dt = honolulu_migration_dt,
  id_v = c("GEOID1", "GEOID2", "FULL1_NAME", "FULL2_NAME"),
  measure_v = c("MOVEDIN_M", "MOVEDOUT_M", "MOVEDNET_M"),
  value_name = "moe"
)

honolulu_migration_long_dt <- honolulu_migration_est_dt[, moe := honolulu_migration_moe_dt$moe]
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.17: Migration flows data for Honolulu, HI, acs/flows, 2019

honolulu_migration_long_gt <- RplotterPkg::create_table(
  x = honolulu_migration_long_dt[1:6,],
  container_width_px = 600
)
honolulu_migration_long_gt
```

::: task
Get a listing of all the "migration flows" related data sets.
:::

Call `RcensusPkg::get_dataset_names()` for the year 2019:

```{r}
flows_datasets_dt <- RcensusPkg::get_dataset_names(
  filter_title_str = "migration flows",
  vintage = 2019)
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.17-1 Migration flow datasets available, 2019

flows_datasets_gt <- RplotterPkg::create_table(
  x = flows_datasets_dt,
  container_width_px = 400
)
flows_datasets_gt
```

::: task
Get a listing of some of the available variables from the 2019 "acs/flows" dataset.
:::

Call `RcensusPkg::get_variable_names()`:

```{r}
flows_vars_dt <- RcensusPkg::get_variable_names(
  dataset = "acs/flows",
  vintage = 2019
)
```

There are 46 variables available. Some of the more interesting variables include the following:

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 2.17-2: Some interesting variables from acs/flows dataset, 2019

flows_vars_gt <- RplotterPkg::create_table(
  x = flows_vars_dt[5:10],
  container_width_px = 600
)
flows_vars_gt
```

### Conclusion
This concludes the notes on Chapter 2 "An introduction".