---
title: "Notes on 'Analyzing US Census Data"
author: "Rick Dean"
format: 
  html:
    toc: false
    toc-depth: 4
    toc-location: "right"
    number-sections: true
    number-offset: 3
    self-contained: true
    smooth-scroll: true
    code-block-bg: "#f1f3f5"
    code-block-border-left: "#31BAE9"
    code-overflow: wrap
    tbl-cap-location: "bottom"
    fig-width: 7
    fig-asp: 0.6
    fig-align: "center"
    fig-cap-location: "bottom"
    css: ../style.css
    fontsize: 11px
    link-external-newwindow: true
    abstract-title: "Abstract"
    abstract: "The following are notes and R script based on Chapter 4 of the book [Analyzing US Census Data: Methods, Maps, and Models in R](https://walker-data.com/census-r/index.html) by Kyle Walker with its presentation of examples and exercises. The R packages [RcensusPkg](https://github.com/deandevl/RcensusPkg) and [data.table](https://cran.r-project.org/web/packages/data.table/index.html) are used in accessing and manipulating the data respectively.  Graphics support is from the ggplot2 based [RplotterPkg](https://github.com/deandevl/RplotterPkg) and [plotly](https://plotly.com/ggplot2/getting-started/) The tables are created by using the R package [RplotterPkg::create_table()](https://github.com/deandevl/RplotterPkg)."
---

# Exploring US Census data with visualization

::: task
Load the required R packages.
:::

```{r}
#| warning: false
#| message: false

library(usmap)
library(data.table)
library(httr)
library(gt)
library(purrr)
library(ggplot2)
library(stringr)
library(magrittr)
library(RplotterPkg)
library(RcensusPkg)
```

## Basic Census visualization with ggplot2

::: task
From the 2016-2020 "acs/acs5" data set obtain the median household income and age data by county in the state of Georgia.
:::

Call `RcensusPkg::get_vintage_data()`:

```{r}
ga_fips <- usmap::fips("GA")
vars <- c("B19013_001E", "B19013_001M", "B01002_001E", "B01002_001M")

ga_dt <- RcensusPkg::get_vintage_data(
  dataset = "acs/acs5",
  vintage = 2020,
  vars = vars,
  region = "county:*",
  regionin = paste0("state:", ga_fips),
) %>%
data.table::setnames(., old = vars, new = c("medincE","medincM","medageE","medageM")) %>%
.[, `:=`(medincE = as.numeric(medincE), medageE = as.numeric(medageE))] %>%
.[, .(GEOID,NAME,medincE,medageE)]  
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 4.0: Household median income and age across Georgia counties,acs/acs5,2020

ga_gt <- RplotterPkg::create_table(
  x = ga_dt[1:6,],
  container_width_px = 400
)
ga_gt
```

### Getting started with ggplot2

::: task
Graph the histogram of the variable "medincE" across 30 bins.
:::

```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.1: Histogram of median household income, Georgia counties, acs/acs5, 2020, (number of bins set to 30)

RplotterPkg::create_histogram_plot(
  df = ga_dt,
  aes_x = "medincE",
  x_title = "Median Income",
  y_title = "Count",
  rot_y_tic_label = TRUE,
  bar_fill = "green",
  bar_color = "green",
  bar_alpha = 0.5,
  bins = 30,
  x_major_breaks = seq(20000, 120000, 20000),
  x_labels = function(x) paste0("$", x/1000,"k")
)
```

::: task
Graph the histogram of the variable "medincE" across 15 bins.
:::


```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.2: Histogram with the number of bins reduced to 15, acs/acs5, 2020

RplotterPkg::create_histogram_plot(
  df = ga_dt,
  aes_x = "medincE",
  x_title = "Median Income",
  y_title = "Count",
  rot_y_tic_label = TRUE,
  bar_fill = "green",
  bar_color = "green",
  bar_alpha = 0.5,
  bins = 15,
  x_major_breaks = seq(20000, 120000, 20000),
  x_labels = function(x) paste0("$", x/1000,"k")
)
```

::: task
Graph the box-plot (box-and-whisker) of "medincE".
:::

```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.3: Box plot of median household income, Georgia counties

RplotterPkg::create_box_plot(
  df = ga_dt,
  aes_y = "medincE",
  x_title = " ",
  y_title = "Median Income",
  box_color = "green",
  rot_y_tic_label = TRUE,
  y_scientific = FALSE
)
```

### Visualizing multivariate relationships with scatter plots

::: task
From the above Georgia household data frame `ga_dt` produce a scatter plot of "medageE" vs "medincE".
:::

```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.4: Scatter plot of median age and median household income, counties in Georgia

RplotterPkg::create_scatter_plot(
  df = ga_dt,
  aes_x = "medageE",
  aes_y = "medincE",
  x_title = "Median Age",
  y_title = "Median Income",
  rot_y_tic_label = TRUE,
  pts_fill = "green",
  pts_size = 1.5,
  x_y_scientific = c(FALSE, FALSE)
)
```

In measuring the relationship between age and income, the R language offers two simple functions. First, the `stats::lm()` function can be used to fit a linear model. Second, we can submit the resulting `stats::lm()` object to `stats:predict()` and return fitted values along with per point standard errors for computing upper/lower confidence bands for the fit.

::: task
Define a simple linear regression between variables "medageE" and "medinc E" from the `ga_dt` data frame using `stats::lm()`.
:::

Use `stats::lm()` to define the linear model:

```{r}
age_income_model <- stats::lm(medincE ~ medageE, data = ga_dt)
```

Submit the model to `stats::predict()` and return the fitted values along with computing the upper/lower confidence values:

```{r}
a_predict <- stats::predict(object = age_income_model, se.fit = TRUE)
ci_lower <- a_predict$fit - (2 * a_predict$se.fit)
ci_upper <- a_predict$fit + (2 * a_predict$se.fit)
```

Append the fitted and confidence level values to `ga_dt`:

```{r}
ga_dt[, `:=`(fit = a_predict$fit, ci_lower = ci_lower, ci_upper = ci_upper)]
```

```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.5: Scatter plot with linear relationship superimposed on the graphic

RplotterPkg::create_scatter_plot(
  df = ga_dt,
  aes_x = "medageE",
  aes_y = "medincE",
  aes_CI_lwr = "ci_lower",
  aes_CI_upr = "ci_upper",
  x_title = "Median Age",
  y_title = "Median Income",
  rot_y_tic_label = TRUE,
  pts_fill = "green",
  pts_size = 1.5,
  x_y_scientific = c(FALSE, FALSE),
  CI_show_ribbon = TRUE
) + ggplot2::geom_line(aes(y = ga_dt$fit), color="blue", linewidth=1.5)
```

## Customizing ggplot2 visualizations

::: task
Show the percent of commuters that take public transportation to work for the largest metropolitan areas in the United States for vintage 2019.
:::

Get the description of variables ID "DP03_0021PE" and "B01003_001E" in the "acs/acs1/profile" and "acs/acs1" data sets respectively for vintage 2019:

```{r}
DP03_0021PE_dt <- RcensusPkg::get_variable_names(
  dataset = "acs/acs1/profile",
  vintage = 2019,
  vars = "DP03_0021PE"
)
B01003_001E_dt <- RcensusPkg::get_variable_names(
  dataset = "acs/acs1",
  vintage = 2019,
  vars = "B01003_001E"
)
DP03_0021PE_B01003_001E_dt <- rbind(DP03_0021PE_dt,B01003_001E_dt)
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 4.1-1: Description of 'DP03_0021PE' and B01003_001E, acs/acs1/profile,2019

DP03_0021PE_B01003_001E_gt <- RplotterPkg::create_table(
  x = DP03_0021PE_B01003_001E_dt,
  container_width_px = 500
)
DP03_0021PE_B01003_001E_gt
```

::: task
We have both percent estimate with acronym of "DP03_0021PE" and "B01003_001E" available. Get both the percentage of workers commuting on public transportation and the total population for 2019.
:::

Use `RcensusPkg::get_vintage_data()`:

```{r}
commute_percent_dt <- RcensusPkg::get_vintage_data(
  dataset = "acs/acs1/profile",
  vintage = 2019,
  vars = c("DP03_0021PE", "DP03_0021PM"),
  region = "metropolitan statistical area/micropolitan statistical area"
) %>%
data.table::setnames(., old = c("DP03_0021PE", "DP03_0021PM"), new = c("estimate", "moe")) %>%
.[, `:=`(variable = "DP03_0021P", estimate = as.numeric(estimate), moe = as.numeric(moe))] %>% 
.[, .(GEOID, NAME, variable, estimate, moe)] %>%
.[order(-estimate)] 
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 4.1-2: Percentage of workers commuting on public transportation, acs/acs1/profile, 2019

commute_percent_gt <- RplotterPkg::create_table(
  x = commute_percent_dt[1:6,],
  container_width_px = 400
)
commute_percent_gt
```

::: task
Using variable acronym "B01003_001E" get the total population in the metropolitan areas for vintage 2019.
:::

Use `RcensusPkg::get_vintage_data()`:

```{r}
pop_dt <- RcensusPkg::get_vintage_data(
  dataset = "acs/acs1",
  vintage = 2019,
  vars = c("B01003_001E", "B01003_001M"),
  region = "metropolitan statistical area/micropolitan statistical area") %>%
data.table::setnames(., old = c("B01003_001E", "B01003_001M"), new = c("summary_est", "summary_moe")) %>%  
.[, summary_moe := ifelse(summary_moe == -555555555, NA, summary_moe)] %>% 
.[, `:=`(summary_est = as.numeric(summary_est), summary_moe = as.numeric(summary_moe))] %>% 
.[order(-summary_est)] %>% 
.[, .(GEOID, NAME, summary_est, summary_moe)] 
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 4.1-3: Total Population of Metropolitan Areas, acs/acs5, 2019

pop_gt <- RplotterPkg::create_table(
  x =pop_dt[1:6,],
  container_width_px = 400
)
pop_gt
```

::: task
We have the data frames for the percent of commuters using public transportation (`commute_percent_dt`) and the total population (`pop_dt`) of metropolitan areas for 2019. Join these two data frames by the common "GEOID" column so that we can perform statistical analysis.
:::

Join the commute and population dataframe by variable "NAME":

```{r}
# set keys
data.table::setkey(commute_percent_dt, GEOID)
data.table::setkey(pop_dt, GEOID)

commute_pop_dt <- commute_percent_dt[pop_dt] %>%
.[, .(GEOID,NAME,variable,estimate,moe,summary_est,summary_moe)] %>%
.[order(-summary_est)]
```

```{r,results='asis'}
#| code-fold: true
#| tbl-cap: |
#|   Table 4.1: Large metro areas by public transit commuting share, acs/acs5, 2019

commute_pop_gt <- RplotterPkg::create_table(
  x = commute_pop_dt[1:6,],
  container_width_px = 550
)
commute_pop_gt
```

### Improving plot legibility

::: task
Show an improved bar chart of the `commute_pop_dt` data.table.
:::

```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.8: A cleaned-up bar chart with ggplot2

commute_pop_dt %>%
.[, NAME := stringr::str_remove(NAME, "-.*$")] %>%
.[, NAME := stringr::str_remove(NAME, ",.*$")] %>%
.[, NAME := as.factor(NAME)]

RplotterPkg::create_bar_plot(
  df = commute_pop_dt[1:20,],
  aes_x = "NAME",
  aes_y = "estimate",
  title = "Public transit commute share",
  subtitle = "2019 1-year ACS estimates",
  x_title = "ACS estimate",
  do_coord_flip = TRUE,
  rot_y_tic_label = TRUE,
  order_bars = "asc",
  bar_fill = "navy",
  bar_color = "white",
  bar_size = 1.0,
  bar_alpha = 0.5,
  y_labels = c("0%", "10%", "20%", "30%"),
)
```

### Custom styling of ggplot2 charts

### Exporting data visualizations from R

::: task
Export the above bar chart as a png image.
:::

```{r}
a_plot <- RplotterPkg::create_bar_plot(
  df = commute_pop_dt[1:20,],
  aes_x = "NAME",
  aes_y = "estimate",
  caption = "Figure 4.7: An improved bar chart with ggplot2",
  do_coord_flip = TRUE,
  rot_y_tic_label = TRUE,
  order_bars = "asc",
  bar_fill = "navy",
  bar_color = "navy",
  bar_alpha = 0.5,
  bar_width = .85,
  y_labels = c("0%", "10%", "20%", "30%"),
  png_file_path = "commute_percent_barchart.png",
  png_width_height = c(850, 550)
)
```

## Visualizing margins of error

> ...it is also often useful to visualize those margins of error to illustrate the degree of uncertainty around estimates, especially when making comparisons between those estimates.

### Data setup

We will be looking at the median household income across counties in Maine from the "acs/acs5" with vintage 2020.

::: task
Start by getting the Maine county total population data (variable "P1_001N") from the 2020 Decennial Census.
:::

```{r}
me_fips <- usmap::fips("ME")

me_pop_dt <- RcensusPkg::get_vintage_data(
  dataset = "dec/pl",
  vintage = 2020,
  vars = "P1_001N",
  region = "county:*",
  regionin = paste0("state:", me_fips)) %>%
data.table::setnames(., old = "P1_001N", new = "value") %>%
.[, `:=`(variable = "totalpop", value = as.numeric(value))] %>%
.[, .(GEOID,NAME,variable,value)] %>%
.[order(-value),]  
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 4.2: Population sizes of counties in Maine, dec/pl, 2020

me_pop_gt <- RplotterPkg::create_table(
  x = me_pop_dt,
  container_width_px = 400
)
me_pop_gt
```

> There are seventeen counties in Main, ranging in population from a maximum of 303,069 to a minimum of 16,800. In turn, estimates for the counties with small population sizes are likely to be subject to a larger margin of error than those with a larger baseline populations.

::: task
Get the Maine total household income along with their margin of errors across the counties for 2020.
:::

We want data for variable acronym "B19013_001" from the 2016-2020 ACS:

```{r}
me_income_dt <- RcensusPkg::get_vintage_data(
  dataset = "acs/acs5",
  vintage = 2020,
  vars = c("B19013_001E", "B19013_001M"),
  region = "county:*",
  regionin = paste0("state:", me_fips)) %>%
  data.table::setnames(., old = c("B19013_001E", "B19013_001M"), new = c("estimate", "moe")) %>%
  .[, `:=`(estimate = as.numeric(estimate), moe = as.numeric(moe))] %>% 
  .[, NAME := stringr::str_remove(NAME, " County, Maine")] %>%  
  .[order(estimate)] %>%                                                 
  .[, NAME := factor(NAME, levels = NAME)] %>%
  .[, .(GEOID,NAME,estimate,moe)] %>% 
  .[order(-moe),] 
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 4.2-1 Household income of counties in Maine, acs/acs5, 2020

me_income_gt <- RplotterPkg::create_table(
  x = me_income_dt,
  container_width_px = 400
)
me_income_gt
```

::: task
Create a dot plot of Maine's county household incomes.
:::

```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.10: A dot plot of median household income by county in Maine

RplotterPkg::create_scatter_plot(
  df = me_income_dt,
  aes_x = "estimate",
  aes_y = "NAME",
  title = "Median Household Income Estimates",
  subtitle = "Counties in Maine from ACS 2016-2020 Survey",
  pts_fill = "#12891b",
  pts_size = 5.0,
  x_title = "ACS estimate",
  x_labels = function(x) paste0("$", prettyNum(x, big.mark = ",", scientific = F)),
  rot_y_tic_label = TRUE
)
```

### Using error bars for margins of error

::: task
Rank the margin of error values for the household incomes in `me_income_dt`.
:::

Reorder `me_income_dt` by descending "moe" values:

```{r}
moe_ranked_dt <- me_income_dt[order(-moe)] %>%
.[, variable := "hhincome"] %>%
.[, .(GEOID,NAME,variable,estimate,moe)]  
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 4.3: Margins of error in Maine, acs/acs5, 2020

moe_ranked_gt <- RplotterPkg::create_table(
  x = moe_ranked_dt,
  container_width_px = 400
)
moe_ranked_gt
```

> ...margins of error around the estimated median household incomes vary from a low of $1563 (Cumberland County with population of 303069) to a high of $4616 (Sagadahoc County with a population of 36699)

::: task
Repeat the above dot plot of household income with error bars around each point showing the degree of uncertainty based on the "moe" values.
:::

```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.11: Median household income by county in Maine with error bars shown

RplotterPkg::create_scatter_plot(
  df = me_income_dt,
  aes_x = "estimate",
  aes_y = "NAME",
  title = "Median Household Income Estimates",
  subtitle = "Counties in Maine from ACS 2016-2020 Survey",
  pts_fill = "#12891b",
  pts_size = 5.0,
  x_title = "ACS estimate",
  x_labels = function(x) paste0("$", prettyNum(x, big.mark = ",", scientific = F)),
  rot_y_tic_label = TRUE
) + geom_errorbarh(aes(xmin = estimate - moe, xmax = estimate + moe))
```

## Visualizing ACS estimates over time

::: task
As a time-series visualization example, obtain the median home value ("B25077_001E") for Deschutes County, Oregon back to 2005 through 2019.
:::

Get the data using `RcensusPkg::get_multi_vintage_data()`:

```{r}
deschutes_fips <- usmap::fips("OR","Deschutes")

deschutes_val_dt <- RcensusPkg::get_multi_vintage_data(
  dataset = "acs/acs1",
  vintage_v = 2005:2019,
  vars = c("B25077_001E", "B25077_001M"),
  region = paste0("county:", substr(deschutes_fips,3,5)),
  regionin = paste0("state:", substr(deschutes_fips,1,2))) %>%
data.table::setnames(., old = c("B25077_001E", "B25077_001M", "vintage"), new = c("estimate", "moe", "year")) %>%
.[, `:=`(estimate = as.numeric(estimate), moe = as.numeric(moe))] %>% 
.[, variable := "B25077_001"] %>%
.[, `:=`(ci_lwr = estimate - moe, ci_upr = estimate + moe)] %>% 
.[, .(year,GEOID,NAME,variable,estimate,moe,ci_lwr,ci_upr)]   
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 4.4: Time series of median home values in Deschutes County, OR, acs/acs1

deschutes_val_gt <- RplotterPkg::create_table(
  x = deschutes_val_dt[1:6,],
  container_width_px = 600
)
deschutes_val_gt
```

:::task
Draw the Deschutes County home value line chart with error ranges.
:::

```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.13: The Deschutes County home value line chart with error ranges shown

RplotterPkg::create_scatter_plot(
  df = deschutes_val_dt,
  aes_x = "year",
  aes_y = "estimate",
  aes_CI_lwr = "ci_lwr",
  aes_CI_upr = "ci_upr",
  title = "Median Home Values in Deschutes County, Oregon",
  x_title = "Year",
  y_title = "ACS estimate",
  rot_y_tic_label = TRUE,
  y_labels = scales::dollar,
  connect = TRUE,
  pts_size = 3.0,
  pts_fill = "#b136b9",
  x_major_breaks = 2005:2019,
  x_minor_breaks = NULL,
  CI_show_ribbon = TRUE,
  CI_ribbon_color = "navy",
  CI_show_line = FALSE
)
```

## Exploring age and sex structure with population pyramids

### Preparing data from the Population Estimates API

The Population Estimates Program(PEP) offers a dataset named "pep/charagegroups" that has characteristic breakdowns for a number of variables.

::: task
Review the variables offered in "pep/charagegroups" for the vintage 2019.
:::

Call `RcensusPkg::get_variable_names()` for dataset "pep/charagegroups":

```{r}
pep_char_vars_dt <- RcensusPkg::get_variable_names(
  dataset = "pep/charagegroups",
  vintage = 2019
)
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Variables offered in 'pep/charagegroups', pep/charagegroups, 2019

pep_char_vars_gt <- RplotterPkg::create_table(
  x = pep_char_vars_dt[name %in% c("AGEGROUP","HISP","NATION","POP","RACE","SEX","STATE"),],
  container_width_px = 500
)
pep_char_vars_gt
```

Both the "SEX" and "AGEGROUP" are categorical variables with integer values corresponding to string labels.

::: task
Retrieve the integer value/label pairs of "SEX" and "AGEGROUP".
:::

```{r}
sex_cat_dt <- RcensusPkg::get_category_strings(name = "sex")
agegroup_cat_dt <- RcensusPkg::get_category_strings(name = "agegroup", start_idx = 1, end_idx = 19)
```

::: task
Show the "AGEGROUP" values and labels".
:::

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Integer value/label pairs for catagory variable 'AGEGROUP'

agegroup_cat_gt <- RplotterPkg::create_table(
  title = "AGEGROUP Catagory Variable",
  x = agegroup_cat_dt[1:8,],
  container_width_px = 300,
  footnote_title = "There are a total of 19 value/label pairs"
)
agegroup_cat_gt
```

::: task
Show the 3 "SEX" category value/label pairs.
:::

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Integer value/label pairs for catagory variable 'SEX'

sex_cat_gt <- RplotterPkg::create_table(
  x = sex_cat_dt,
  container_width_px = 300
)
sex_cat_gt
```

::: note
The Census Bureau provides a key to the meaning of these and other PEP related categorical variables [here](https://www.census.gov/data/developers/data-sets/popest-popproj/popest/popest-vars.Vintage_2019.html).
:::

::: task
Get the "SEX" and "AGEGROUP" variables from the "pep/charagegroups" dataset for the state of Utah, 2019.
:::

Call `RcensusPkg::get_vintage_data()`: We will use data.tables `sex_cat_dt` and `agegroup_cat_dt` from above to re-value the resultant "SEX" and "AGEGROUP" columns.

```{r}
ut_fips <- usmap::fips("UT")

ut_dt <- RcensusPkg::get_vintage_data(
  dataset = "pep/charagegroups",
  vintage = 2019,
  vars = c("SEX", "AGEGROUP", "POP"),
  region = paste0("state:",ut_fips)) %>%
.[, `:=`(SEX = as.numeric(SEX), AGEGROUP = as.numeric(AGEGROUP))] %>% 
.[, SEX := sex_cat_dt$sex_label[SEX+1]] %>%  
.[, AGEGROUP := agegroup_cat_dt$agegroup_label[AGEGROUP+1]] %>%
data.table::setnames(., old = "POP", new = "value") %>%
.[, .(GEOID,NAME,value,SEX,AGEGROUP)] %>%
na.omit(., cols = "AGEGROUP") %>%
data.table::setorderv(., cols = "SEX")
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 4.5: Age and sex data for Utah from the PEP API, pep/charagegroups, 2019

ut_gt <- RplotterPkg::create_table(
  x = ut_dt[1:6,],
  container_width_px = 400
)
ut_gt
```

::: task
Prepare data frame `ut_dt` for plotting the population pyramid by removing rows with "SEX" equal to "Both Sexes" and "AGEGROUP" equal to "All ages". Also set the "value" values to negative for rows with "AGEGROUP" equal to "Male".
:::

```{r}
ut_pyramid_plot_dt <- ut_dt %>%
  .[SEX != "Both Sexes"] %>% # remove rows with SEX == "Both sexes"
  .[AGEGROUP != "All ages"] %>% # remove rows with AGEGROUP == "All ages"
  .[, value := as.numeric(value)] %>% # set value as numeric
  .[, value := ifelse(SEX == "Male", -value, value)] %>% # re-value 'value' based on SEX value
  .[, AGEGROUP := ifelse(AGEGROUP == "Age 5 to 9 years", "Age 05 to 9 years", AGEGROUP)] %>% # for ordering
  .[, AGEGROUP := stringr::str_remove_all(AGEGROUP, "Age\\s|\\syears")] %>% # shorten the AGEGROUP labels
  .[, AGEGROUP := as.factor(AGEGROUP)] # make AGEGROUP a factor
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 4.6: Filtered and transformed Utah population data, pep/charagegroups, 2019

ut_pyramid_plot_gt <- RplotterPkg::create_table(
  x = ut_pyramid_plot_dt[1:6,],
  container_width_px = 400
)
ut_pyramid_plot_gt
```

### Designing and styling the population pyramid

::: task
Use `RplotterPkg::create_bar_plot()` to create the population pyramid from `ut_pyramid_plot_dt` data.table.
:::

```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.15: A formatted population pyramid of Utah

pyramid_bar_plot <- RplotterPkg::create_bar_plot(
  df = ut_pyramid_plot_dt,
  aes_x = "AGEGROUP",
  aes_y = "value",
  aes_fill = "SEX",
  title = "Population structure in Utah",
  x_title = "2019 Census Bureau population estimate",
  y_title = "Population Estimate",
  y_labels = function(y) paste0(abs(y / 1000), "k"),
  do_coord_flip = TRUE,
  rot_y_tic_label = TRUE,
  legend_key_width = 0.75
)
pyramid_bar_plot
```

## Visualizing group-wise comparisons

::: task
Use multiple plots to compare groups of geographies. An example involves a comparison of median home values by Census tract for six counties in the Portland, Oregon area: Multnomah, which contains the city of Portland, and the suburban counties of Clackamas and Washington. Use the ACS 5-year survey 2020 data set ("acs/acs5").
:::

Get the fips numbers for six counties:

```{r}
or_fips <- usmap::fips(state = "OR")
multnomah_fips <- substr(usmap::fips(state = "OR", county = "Multnomah"),3,5)
clackamas_fips <- substr(usmap::fips(state = "OR", county = "Clackamas"),3,5)
washington_fips <-substr(usmap::fips(state = "OR", county = "Washington"),3,5)
yamhill_fips <- substr(usmap::fips(state = "OR", county = "Yamhill"),3,5)
marion_fips <-substr(usmap::fips(state = "OR", county = "Marion"),3,5)
columbia_fips <-substr(usmap::fips(state = "OR", county = "Columbia"),3,5)

tract_fips <- c(multnomah_fips, clackamas_fips, washington_fips, yamhill_fips, marion_fips, columbia_fips)
```

Get all the tract data into one data.table:

```{r}
home_vals_dt <- NULL
for(a_fips in tract_fips){
  tracts_vals_dt <- RcensusPkg::get_vintage_data(
    dataset = "acs/acs5",
    vintage = 2020,
    vars = c("B25077_001E", "B25077_001M"),
    region = "tract:*",
    regionin = paste0("state:",or_fips,"+county:",a_fips)
  )
  home_vals_dt <- rbind(home_vals_dt, tracts_vals_dt)
}
home_vals_dt <- home_vals_dt %>%
data.table::setnames(., old = c("B25077_001E", "B25077_001M"), new = c("estimate","moe")) %>%
.[, variable := "B25077_001"] %>%
.[, `:=`(estimate = as.numeric(estimate), moe = as.numeric(moe))] %>% 
.[, .(GEOID,NAME,variable,estimate,moe)] %>%
data.table::setorderv(.,cols = "GEOID")
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 4.7: Median home values by Census tract in the Portland, OR area, acs/acs5, 2020

home_vals_gt <- RplotterPkg::create_table(
  x = home_vals_dt[1:6,],
  container_width_px = 400
)
home_vals_gt
```

Do some minor wrangling:

```{r}
home_vals_dt <- home_vals_dt %>%
  .[, c("tract", "county", "state") := tstrsplit(NAME, ",", fixed = TRUE)] %>%   # split NAME string into tract,county,state
  .[, county := stringr::str_remove(county, " County")] %>%
  .[estimate > 0 & moe > 0,] %>%  # filter rows for only positive values
  .[, county := factor(county)]  %>% # county as a factor
  .[, .(GEOID,tract,county,state,variable,estimate,moe)]
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 4.8: Data with NAME column split by comma

home_vals_gt <- RplotterPkg::create_table(
  x = home_vals_dt[1:6,],
  container_width_px = 600
)
home_vals_gt
```

::: task
Aggregate the `home_vals_dt` data.table with grouping by county and show summary statistics on the "estimate" variable.
:::

Compute min, max, mean, and median by county:

```{r}
county_summary_dt <- home_vals_dt[, .(min = min(estimate), max = max(estimate), mean = round(mean(estimate),1), median = stats::median(estimate)), by = county]
```

```{r}
#| code-fold: true
#| tbl-cap: |
#|   Table 4.9: Summary statistics for Census tracts in Portland-area counties

county_summary_gt <- RplotterPkg::create_table(
  x = county_summary_dt,
  container_width_px = 400
)
county_summary_gt
```

::: task
Show the overall kernel density of the "estimate" variable of `home_vals_dt`.
:::

Call `RplotterPkg::create_density_plot()`:

```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.16: A density plot using all values in the dataset


RplotterPkg::create_density_plot(
  df = home_vals_dt,
  aes_x = "estimate",
  x_title = "Home Value",
  x_labels = function(x)paste0("$", prettyNum(x/1000,big.mark = ",",scientific=F)),
  x_limits = c(0, 1000000),
  x_major_breaks = c(250000, 500000, 750000),
  rot_y_tic_label = TRUE,
  density_fill = "blue",
  density_alpha = 0.5
)
```

::: task
Show the home value density by county.
:::

```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.17: A density plot with separate curves for each county

RplotterPkg::create_density_plot(
  df = home_vals_dt[, .(estimate), by = county],
  aes_x = "estimate",
  aes_fill = "county",
  x_title = "Home Value",
  x_labels = function(x)paste0("$", prettyNum(x/1000,big.mark = ",",scientific=F)),
  x_limits = c(0, 1000000),
  x_major_breaks = c(250000, 500000, 750000),
  rot_y_tic_label = TRUE,
  legend_key_width = 0.8
)
```

::: task
Show the home value density by county in multiple charts using `RplotterPkg::multi_panel_grid()` function.
:::

```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.18: An example faceted density plot
#| fig-width: 16
#| fig-height: 16

counties <- levels(home_vals_dt$county)
build_plot <- function(id, df, counties){
  county <- counties[id]
  plot_df <- df[county == counties[[id]], ]
  aplot <- RplotterPkg::create_density_plot(
    df = plot_df,
    aes_x = "estimate",
    subtitle = county,
    x_title = NULL,
    x_labels = function(x) paste0("$", x / 1000, "k"),
    x_limits = c(0, 1000000),
    x_major_breaks = c(250000, 500000, 750000),
    y_limits = c(0, 0.000008),
    y_major_breaks = seq(0, 0.000008, 0.000001),
    y_title = "Density",
    show_minor_grids = FALSE,
    rot_y_tic_label = TRUE,
    density_fill = "blue",
    density_alpha = 0.5
  )
  return(aplot)
}
plot_lst <- purrr::map(1:6,
  build_plot,
  df = home_vals_dt,
  counties = counties
)
names(plot_lst) <- counties
layout <- list(
  plots = plot_lst,
  rows = c(1, 1, 1, 2, 2, 2),
  cols = c(1, 2, 3, 1, 2, 3)
)
RplotterPkg::multi_panel_grid(
 layout = layout,
 title = "Median home values by Census tract in the Portland Area",
 y_tick_width = 1,
 plot_titles = counties
)
```

## Advanced visualization with ggplot2 extensions

### Density ridges

::: task
Repeat the above home value density by county data (`home_vals_dt`) in a "ridge" type of display.
:::

Reshape `home_vals_dt` to a "wide" form using the "county" variable:

```{r}
home_vals_wide_dt <- RcensusPkg::long_to_wide(
  dt = home_vals_dt,
  id_v = "tract",
  parameter_col = "county",
  value_col = "estimate"
)
```

Call `RplotterPkg::create_density_ridge_plot()`:

```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.19: Median home values in Portlan-area counties visualized with RplotterPkg::create_density_ridge_plot
#| fig-width: 8
#| fig-height: 8

RplotterPkg::create_density_ridge_plot(
  df = home_vals_wide_dt,
  title = "Median home value: 2016-2020 ACS estimate",
  variables = c(" Clackamas"," Columbia", " Marion", " Multnomah",  " Washington"," Yamhill"),
  x_title = "Home Value",
  x_limits = c(0, 1000000),
  x_major_breaks = c(250000, 500000, 750000),
  density_fill = "blue",
  x_labels = function(x)paste0("$", prettyNum(x/1000,big.mark = ",",scientific=F)),
  density_alpha = 0.5
)
```

### Interactive visualization with plotly

::: task
Take the ggplot2 object `pyramid_bar_plot` created above and make it interactive using the plotly package.
:::

::: note
Using `plotly::ggplotly()` is great for interactivity but comes with a price. This html article increased from 1.5 MB to 5.4 MB with its addition. It works, but we've commented it out as you'll note in the code below.
:::

```{r}
#| code-fold: true
#| fig-cap: |
#|   Figure 4.22: An interactive population pyramid rendered with ggplotly

#plotly::ggplotly(pyramid_bar_plot)
```

### Conclusion
This concludes the notes on Chapter 4 "Exploring US Census data with visualization".